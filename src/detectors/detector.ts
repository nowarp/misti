import { MistiContext } from "../internals/context";
import { CompilationUnit } from "../internals/ir";
import { MistiTactError } from "../internals/errors";
import { SrcInfo } from "@tact-lang/compiler/dist/grammar/ast";
import {
  Context as SouffleContext,
  Fact,
  FactValue,
  Executor,
} from "../internals/souffle";

export type WarningsBehavior = "union" | "intersect";

export type DetectorName = string;

/**
 * Abstract base class for a detector module, providing an interface for defining various types of detectors.
 */
export abstract class Detector {
  /**
   * Gets the short identifier of the detector, used in analyzer warnings.
   * @returns The unique identifier of the detector.
   */
  get id(): DetectorName {
    return this.constructor.name;
  }

  /**
   * Defines the behavior of warnings generated by this detector when working with
   * multiple projects within a single Tact configuration.
   *
   * Here are the available options:
   * 1. `"union"`
   * Leave this value if you don't care about warnings generated in other projects.
   * 2. `"intersect"`
   * If the warning is generated for some source location of the imported file,
   * it should be generated by each of the projects. Example: Constants from an
   * imported file should not be reported iff they are unused in all the projects,
   * so you need "intersect".
   */
  public get shareImportedWarnings(): WarningsBehavior {
    return "union";
  }

  /**
   * Executes Souffle program for this detector converting output facts to warnings.
   * @param program Souffle context with all the declarations, rules and facts added.
   * @param callback A function that creates warnings from output facts.
   */
  protected executeSouffle(
    ctx: MistiContext,
    program: SouffleContext<SrcInfo>,
    callback: (fact: Fact<FactValue, SrcInfo>) => MistiTactError | undefined,
  ): MistiTactError[] {
    const executor = ctx.config.soufflePath
      ? new Executor<SrcInfo>({
          inputDir: ctx.config.soufflePath,
          outputDir: ctx.config.soufflePath,
        })
      : new Executor<SrcInfo>();
    const result = executor.executeSync(program);
    if (!result.success) {
      throw new Error(
        `Error executing Souffl√© for ${this.id}:\n${result.stderr}`,
      );
    }
    return Array.from(result.results.entries.values()).reduce<MistiTactError[]>(
      (acc, facts) => {
        return acc.concat(
          facts.reduce<MistiTactError[]>((innerAcc, fact) => {
            const error = callback(fact);
            if (error) {
              innerAcc.push(error);
            }
            return innerAcc;
          }, []),
        );
      },
      [],
    );
  }

  /**
   * Executes the detector's logic to check for issues within the provided compilation unit.
   * @param ctx Misti context.
   * @param cu The compilation unit to be analyzed.
   * @returns List of errors has highlighted by this detector.
   */
  abstract check(ctx: MistiContext, cu: CompilationUnit): MistiTactError[];

  /**
   * Returns `true` if the identifier with the given name should not be reported
   * by unused variables detectors.
   */
  protected skipUnused(ctx: MistiContext, name: string): boolean {
    return name.startsWith(ctx.config.unusedPrefix);
  }
}

/**
 * A mapping of detector names to functions that load detector instances.
 * This allows for lazy loading of detectors, which may include importing necessary modules dynamically.
 */
const BuiltInDetectors: Record<string, () => Promise<Detector>> = {
  DivideBeforeMultiply: () =>
    import("./builtin/divideBeforeMultiply").then(
      (module) => new module.DivideBeforeMultiply(),
    ),
  ReadOnlyVariables: () =>
    import("./builtin/readOnlyVariables").then(
      (module) => new module.ReadOnlyVariables(),
    ),
  NeverAccessedVariables: () =>
    import("./builtin/neverAccessedVariables").then(
      (module) => new module.NeverAccessedVariables(),
    ),
  UnboundLoops: () =>
    import("./builtin/unboundLoops").then(
      (module) => new module.UnboundLoops(),
    ),
  ZeroAddress: () =>
    import("./builtin/zeroAddress").then((module) => new module.ZeroAddress()),
};

/**
 * Asynchronously retrieves a built-in detector by its name.
 * If the detector is found in the BuiltInDetectors registry, it is loaded and returned;
 * otherwise, a warning is logged and `undefined` is returned.
 *
 * @param ctx Misti context.
 * @param name The name of the detector to retrieve. This name must match a key in the BuiltInDetectors object.
 * @returns A Promise that resolves to a Detector instance or `undefined` if the detector cannot be found or fails to load.
 */
export async function findBuiltInDetector(
  ctx: MistiContext,
  name: string,
): Promise<Detector | undefined> {
  const detectorLoader = BuiltInDetectors[name];
  if (!detectorLoader) {
    ctx.logger.warn(`Built-in detector ${name} not found.`);
    return undefined;
  }
  try {
    return await detectorLoader();
  } catch (error) {
    ctx.logger.error(`Error loading built-in detector ${name}: ${error}`);
    return undefined;
  }
}
