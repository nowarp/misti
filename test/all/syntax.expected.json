{
  "kind": "warnings",
  "warnings": [
    {
      "projectName": "syntax",
      "warnings": [
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":125,\"col\":9,\"detectorId\":\"NeverAccessedVariables\",\"severity\":\"MEDIUM\",\"message\":\"Variable value is never accessed\\ntest/all/syntax.tact:125:9:\\n  124 |     fun funcWithStateRead() {\\n> 125 |         let value = self.addr;\\n                ^~~~~~~~~~~~~~~~~~~~~~\\n  126 |     }\\nHelp: Consider removing the variable\\nSee: https://nowarp.io/tools/misti/docs/detectors/NeverAccessedVariables\",\"quickfixes\":[]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":141,\"col\":9,\"detectorId\":\"NeverAccessedVariables\",\"severity\":\"MEDIUM\",\"message\":\"Variable currentTime is never accessed\\ntest/all/syntax.tact:141:9:\\n  140 |     fun funcWithMultipleEffects() {\\n> 141 |         let currentTime: Int = now();\\n                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n  142 |         let randValue: Int = random(1, 100);\\nHelp: Consider removing the variable\\nSee: https://nowarp.io/tools/misti/docs/detectors/NeverAccessedVariables\",\"quickfixes\":[]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":142,\"col\":9,\"detectorId\":\"NeverAccessedVariables\",\"severity\":\"MEDIUM\",\"message\":\"Variable randValue is never accessed\\ntest/all/syntax.tact:142:9:\\n  141 |         let currentTime: Int = now();\\n> 142 |         let randValue: Int = random(1, 100);\\n                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n  143 |         if (1 > 42) {\\nHelp: Consider removing the variable\\nSee: https://nowarp.io/tools/misti/docs/detectors/NeverAccessedVariables\",\"quickfixes\":[]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":143,\"col\":9,\"detectorId\":\"FalseCondition\",\"severity\":\"MEDIUM\",\"message\":\"Condition always evaluates to false\\ntest/all/syntax.tact:143:9:\\n  142 |         let randValue: Int = random(1, 100);\\n> 143 |         if (1 > 42) {\\n                ^~~~~~~~~~~~~\\n  144 |             nativeRandomizeLt();\\nHelp: Remove the condition\\nSee: https://nowarp.io/tools/misti/docs/detectors/FalseCondition\",\"quickfixes\":[{\"kind\":\"delete\",\"description\":\"Remove the condition\",\"shown\":true,\"range\":{\"start\":{\"line\":143,\"column\":9},\"end\":{\"line\":3,\"column\":10}}}]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":196,\"col\":9,\"detectorId\":\"FalseCondition\",\"severity\":\"MEDIUM\",\"message\":\"Condition always evaluates to false\\ntest/all/syntax.tact:196:9:\\n  195 |         while (false) {}\\n> 196 |         while (false) {\\n                ^~~~~~~~~~~~~~~\\n  197 |             dump(\\\"something\\\");\\nHelp: Remove the condition\\nSee: https://nowarp.io/tools/misti/docs/detectors/FalseCondition\",\"quickfixes\":[{\"kind\":\"delete\",\"description\":\"Remove the condition\",\"shown\":true,\"range\":{\"start\":{\"line\":196,\"column\":9},\"end\":{\"line\":3,\"column\":10}}}]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":200,\"col\":9,\"detectorId\":\"FalseCondition\",\"severity\":\"MEDIUM\",\"message\":\"Condition always evaluates to false\\ntest/all/syntax.tact:200:9:\\n  199 |         // Suggested to replace code\\n> 200 |         if (1 == 2) { return true; }\\n                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n  201 |         else { return false; }\\nHelp: Remove the condition\\nSee: https://nowarp.io/tools/misti/docs/detectors/FalseCondition\",\"quickfixes\":[{\"kind\":\"delete\",\"description\":\"Remove the condition\",\"shown\":true,\"range\":{\"start\":{\"line\":200,\"column\":9},\"end\":{\"line\":2,\"column\":31}}}]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":166,\"col\":16,\"detectorId\":\"SuspiciousLoop\",\"severity\":\"MEDIUM\",\"message\":\"Infinite loop detected\\ntest/all/syntax.tact:166:16:\\n  165 |     receive() {\\n> 166 |         while (true) {\\n                       ^~~~\\n  167 |             self.m.set(1, 2);\\nHelp: Avoid unbounded conditions in loops\\nSee: https://nowarp.io/tools/misti/docs/detectors/SuspiciousLoop\",\"quickfixes\":[]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":196,\"col\":16,\"detectorId\":\"SuspiciousLoop\",\"severity\":\"MEDIUM\",\"message\":\"Loop condition is always false\\ntest/all/syntax.tact:196:16:\\n  195 |         while (false) {}\\n> 196 |         while (false) {\\n                       ^~~~~\\n  197 |             dump(\\\"something\\\");\\nHelp: The condition is always false; the body will never execute\\nSee: https://nowarp.io/tools/misti/docs/detectors/SuspiciousLoop\",\"quickfixes\":[]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":120,\"col\":9,\"detectorId\":\"SuboptimalSend\",\"severity\":\"MEDIUM\",\"message\":\"Prefer `message` over `send`\\ntest/all/syntax.tact:120:9:\\n  119 |         let amount: Int = 100;\\n> 120 |         send(SendParameters{ to: self.addr, value: amount });\\n                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n  121 |     }\\nHelp: Use more gas-efficient `message` function: https://docs.tact-lang.org/ref/core-common/#message\\nSee: https://nowarp.io/tools/misti/docs/detectors/SuboptimalSend\",\"quickfixes\":[]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":130,\"col\":35,\"detectorId\":\"ZeroAddress\",\"severity\":\"LOW\",\"message\":\"Using zero address\\ntest/all/syntax.tact:130:35:\\n  129 |     fun funcWithStateWrite1() {\\n> 130 |         self.addr = newAddress(0, 0);\\n                                          ^\\n  131 |         self.b.storeAddress(self.addr);\\nHelp: Consider changing code to avoid using it. For example, you could pass the address during the deployment.\\nSee: https://nowarp.io/tools/misti/docs/detectors/ZeroAddress\",\"quickfixes\":[]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":161,\"col\":5,\"detectorId\":\"UnboundMap\",\"severity\":\"LOW\",\"message\":\"Map self.m could be unbound\\ntest/all/syntax.tact:161:5:\\n  160 | contract A {\\n> 161 |     m: map<Int, Int> = null;\\n            ^~~~~~~~~~~~~~~~~~~~~~~\\n  162 |     get fun m(): map<Int, Int> {\\nThere are operations adding elements to this map, but there is no API to remove them\\nHelp: Consider adding a method to remove elements or suppress this warning\\nSee: https://nowarp.io/tools/misti/docs/detectors/UnboundMap\",\"quickfixes\":[]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":200,\"col\":9,\"detectorId\":\"EtaLikeSimplifications\",\"severity\":\"LOW\",\"message\":\"Return the condition directly\\ntest/all/syntax.tact:200:9:\\n  199 |         // Suggested to replace code\\n> 200 |         if (1 == 2) { return true; }\\n                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n  201 |         else { return false; }\\nHelp: Replace with: return 1 == 2;\\nSee: https://nowarp.io/tools/misti/docs/detectors/EtaLikeSimplifications\",\"quickfixes\":[{\"kind\":\"replace\",\"shown\":true,\"description\":\"Return the condition directly\",\"replacements\":[{\"range\":{\"start\":{\"line\":200,\"column\":9},\"end\":{\"line\":2,\"column\":31}},\"value\":\"return 1 == 2;\"}]}]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":41,\"col\":35,\"detectorId\":\"DumpIsUsed\",\"severity\":\"INFO\",\"message\":\"Found `dump` usage\\ntest/all/syntax.tact:41:35:\\n  40 |     try { /* empty */ }\\n> 41 |     try { a = 19; } catch (err) { dump(err); }\\n                                         ^~~~~~~~~\\n  42 | }\\nUsing `dump` in production code can sometimes indicate complex code that requires additional review\\n\\nSee: https://nowarp.io/tools/misti/docs/detectors/DumpIsUsed\",\"quickfixes\":[]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":67,\"col\":9,\"detectorId\":\"DumpIsUsed\",\"severity\":\"INFO\",\"message\":\"Found `dump` usage\\ntest/all/syntax.tact:67:9:\\n  66 |     } catch (err) {\\n> 67 |         dump(err);\\n               ^~~~~~~~~\\n  68 |     }\\nUsing `dump` in production code can sometimes indicate complex code that requires additional review\\n\\nSee: https://nowarp.io/tools/misti/docs/detectors/DumpIsUsed\",\"quickfixes\":[]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":48,\"col\":7,\"detectorId\":\"PreferAugmentedAssign\",\"severity\":\"INFO\",\"message\":\"Prefer augmented assignment: i += 1\\ntest/all/syntax.tact:48:7:\\n  47 |     while (i < 10) {\\n> 48 |       i = i + 1;\\n             ^~~~~~~~~~\\n  49 |       sum = sum + i;\\nHelp: Consider using augmented assignment instead: i += 1\\nSee: https://nowarp.io/tools/misti/docs/detectors/PreferAugmentedAssign\",\"quickfixes\":[]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":49,\"col\":7,\"detectorId\":\"PreferAugmentedAssign\",\"severity\":\"INFO\",\"message\":\"Prefer augmented assignment: sum += i\\ntest/all/syntax.tact:49:7:\\n  48 |       i = i + 1;\\n> 49 |       sum = sum + i;\\n             ^~~~~~~~~~~~~~\\n  50 |     }\\nHelp: Consider using augmented assignment instead: sum += i\\nSee: https://nowarp.io/tools/misti/docs/detectors/PreferAugmentedAssign\",\"quickfixes\":[]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":52,\"col\":7,\"detectorId\":\"PreferAugmentedAssign\",\"severity\":\"INFO\",\"message\":\"Prefer augmented assignment: i -= 1\\ntest/all/syntax.tact:52:7:\\n  51 |     do {\\n> 52 |       i = i - 1;\\n             ^~~~~~~~~~\\n  53 |       sum = sum + i;\\nHelp: Consider using augmented assignment instead: i -= 1\\nSee: https://nowarp.io/tools/misti/docs/detectors/PreferAugmentedAssign\",\"quickfixes\":[]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":53,\"col\":7,\"detectorId\":\"PreferAugmentedAssign\",\"severity\":\"INFO\",\"message\":\"Prefer augmented assignment: sum += i\\ntest/all/syntax.tact:53:7:\\n  52 |       i = i - 1;\\n> 53 |       sum = sum + i;\\n             ^~~~~~~~~~~~~~\\n  54 |     } until (i > 10);\\nHelp: Consider using augmented assignment instead: sum += i\\nSee: https://nowarp.io/tools/misti/docs/detectors/PreferAugmentedAssign\",\"quickfixes\":[]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":56,\"col\":7,\"detectorId\":\"PreferAugmentedAssign\",\"severity\":\"INFO\",\"message\":\"Prefer augmented assignment: i += 1\\ntest/all/syntax.tact:56:7:\\n  55 |     repeat (10) {\\n> 56 |       i = i + 1;\\n             ^~~~~~~~~~\\n  57 |       sum = sum + i;\\nHelp: Consider using augmented assignment instead: i += 1\\nSee: https://nowarp.io/tools/misti/docs/detectors/PreferAugmentedAssign\",\"quickfixes\":[]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":57,\"col\":7,\"detectorId\":\"PreferAugmentedAssign\",\"severity\":\"INFO\",\"message\":\"Prefer augmented assignment: sum += i\\ntest/all/syntax.tact:57:7:\\n  56 |       i = i + 1;\\n> 57 |       sum = sum + i;\\n             ^~~~~~~~~~~~~~\\n  58 |     }\\nHelp: Consider using augmented assignment instead: sum += i\\nSee: https://nowarp.io/tools/misti/docs/detectors/PreferAugmentedAssign\",\"quickfixes\":[]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":76,\"col\":9,\"detectorId\":\"PreferAugmentedAssign\",\"severity\":\"INFO\",\"message\":\"Prefer augmented assignment: i += 1\\ntest/all/syntax.tact:76:9:\\n  75 |     while (i < 10) {\\n> 76 |         i = i + 1;\\n               ^~~~~~~~~~\\n  77 |         sum = sum + i;\\nHelp: Consider using augmented assignment instead: i += 1\\nSee: https://nowarp.io/tools/misti/docs/detectors/PreferAugmentedAssign\",\"quickfixes\":[]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":77,\"col\":9,\"detectorId\":\"PreferAugmentedAssign\",\"severity\":\"INFO\",\"message\":\"Prefer augmented assignment: sum += i\\ntest/all/syntax.tact:77:9:\\n  76 |         i = i + 1;\\n> 77 |         sum = sum + i;\\n               ^~~~~~~~~~~~~~\\n  78 |     }\\nHelp: Consider using augmented assignment instead: sum += i\\nSee: https://nowarp.io/tools/misti/docs/detectors/PreferAugmentedAssign\",\"quickfixes\":[]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":81,\"col\":9,\"detectorId\":\"PreferAugmentedAssign\",\"severity\":\"INFO\",\"message\":\"Prefer augmented assignment: i -= 1\\ntest/all/syntax.tact:81:9:\\n  80 |     do {\\n> 81 |         i = i - 1;\\n               ^~~~~~~~~~\\n  82 |         sum = sum + i;\\nHelp: Consider using augmented assignment instead: i -= 1\\nSee: https://nowarp.io/tools/misti/docs/detectors/PreferAugmentedAssign\",\"quickfixes\":[]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":82,\"col\":9,\"detectorId\":\"PreferAugmentedAssign\",\"severity\":\"INFO\",\"message\":\"Prefer augmented assignment: sum += i\\ntest/all/syntax.tact:82:9:\\n  81 |         i = i - 1;\\n> 82 |         sum = sum + i;\\n               ^~~~~~~~~~~~~~\\n  83 |     } until (i <= 0);\\nHelp: Consider using augmented assignment instead: sum += i\\nSee: https://nowarp.io/tools/misti/docs/detectors/PreferAugmentedAssign\",\"quickfixes\":[]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":86,\"col\":9,\"detectorId\":\"PreferAugmentedAssign\",\"severity\":\"INFO\",\"message\":\"Prefer augmented assignment: i += 1\\ntest/all/syntax.tact:86:9:\\n  85 |     repeat (10) {\\n> 86 |         i = i + 1;\\n               ^~~~~~~~~~\\n  87 |         sum = sum + i;\\nHelp: Consider using augmented assignment instead: i += 1\\nSee: https://nowarp.io/tools/misti/docs/detectors/PreferAugmentedAssign\",\"quickfixes\":[]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":87,\"col\":9,\"detectorId\":\"PreferAugmentedAssign\",\"severity\":\"INFO\",\"message\":\"Prefer augmented assignment: sum += i\\ntest/all/syntax.tact:87:9:\\n  86 |         i = i + 1;\\n> 87 |         sum = sum + i;\\n               ^~~~~~~~~~~~~~\\n  88 |     }\\nHelp: Consider using augmented assignment instead: sum += i\\nSee: https://nowarp.io/tools/misti/docs/detectors/PreferAugmentedAssign\",\"quickfixes\":[]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":96,\"col\":9,\"detectorId\":\"PreferAugmentedAssign\",\"severity\":\"INFO\",\"message\":\"Prefer augmented assignment: sum += value\\ntest/all/syntax.tact:96:9:\\n  95 |     foreach (key, value in m) {\\n> 96 |         sum = sum + value;\\n               ^~~~~~~~~~~~~~~~~~\\n  97 |     }\\nHelp: Consider using augmented assignment instead: sum += value\\nSee: https://nowarp.io/tools/misti/docs/detectors/PreferAugmentedAssign\",\"quickfixes\":[]}",
        "{\"file\":\"/home/jubnzv/Dev/misti/test/all/syntax.tact\",\"line\":156,\"col\":1,\"detectorId\":\"AsmIsUsed\",\"severity\":\"INFO\",\"message\":\"asm function is used\\ntest/all/syntax.tact:156:1:\\n  155 | // Checks if we add asm functions to IR entries correctly\\n> 156 | asm(-> 1 0) extends mutates fun loadRefEx(self: Slice): Cell { LDREF }\\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n  157 | fun callAsm(s: Slice): Cell { return s.loadRefEx(); }\\nUsing TVM assembly is a potentially dangerous operation that requires additional review\\n\\nSee: https://nowarp.io/tools/misti/docs/detectors/AsmIsUsed\",\"quickfixes\":[]}"
      ]
    }
  ],
  "logs": {
    "debug": [
      "Parsing project syntax ...",
      "   > 👀 Enabling external",
      "   > 👀 Enabling nullChecks",
      "node_modules/@tact-lang/compiler/dist/stdlib/stdlib/std/internal/text.tact:   431 |     let b: StringBuilder = beginComment();\n> 432 |     b.append(self);\n            ^\n  433 |     return b.toCell();\n\nUnsupported contract method access: id",
      "node_modules/@tact-lang/compiler/dist/stdlib/stdlib/std/internal/text.tact:   540 | extends fun fromBase64(self: Slice): Slice {\n> 541 |     let size: Int = self.bits() / 8;\n                            ^~~~\n  542 |     let result: Builder = beginCell();\n\nAccessing an unknown contract: self",
      "node_modules/@tact-lang/compiler/dist/stdlib/stdlib/std/internal/text.tact:   544 |     repeat (size) {\n> 545 |         let code: Int = self.loadUint(8);\n                                ^~~~\n  546 |         if (code >= 65 && code <= 90) { // A-Z\n\nAccessing an unknown contract: self",
      "node_modules/@tact-lang/compiler/dist/stdlib/stdlib/std/internal/text.tact:   546 |         if (code >= 65 && code <= 90) { // A-Z\n> 547 |             result = result.storeUint(code - 65, 6);\n                             ^~~~~~\n  548 |         } else if (code >= 97 && code <= 122) { // a-z\n\nUnsupported contract method access: id",
      "node_modules/@tact-lang/compiler/dist/stdlib/stdlib/std/internal/text.tact:   548 |         } else if (code >= 97 && code <= 122) { // a-z\n> 549 |             result = result.storeUint(code - (97 - 26), 6);\n                             ^~~~~~\n  550 |         } else if (code >= 48 && code <= 57) { // 0-9\n\nUnsupported contract method access: id",
      "node_modules/@tact-lang/compiler/dist/stdlib/stdlib/std/internal/text.tact:   550 |         } else if (code >= 48 && code <= 57) { // 0-9\n> 551 |             result = result.storeUint(code + (52 - 48), 6);\n                             ^~~~~~\n  552 |         } else if (code == 45 || code == 43) { // - or +\n\nUnsupported contract method access: id",
      "node_modules/@tact-lang/compiler/dist/stdlib/stdlib/std/internal/text.tact:   552 |         } else if (code == 45 || code == 43) { // - or +\n> 553 |             result = result.storeUint(62, 6);\n                             ^~~~~~\n  554 |         } else if (code == 95 || code == 47) { // _ or /\n\nUnsupported contract method access: id",
      "node_modules/@tact-lang/compiler/dist/stdlib/stdlib/std/internal/text.tact:   554 |         } else if (code == 95 || code == 47) { // _ or /\n> 555 |             result = result.storeUint(63, 6);\n                             ^~~~~~\n  556 |         } else if (code == 61) { // =\n\nUnsupported contract method access: id",
      "node_modules/@tact-lang/compiler/dist/stdlib/stdlib/std/internal/text.tact:   563 |     // Padding\n> 564 |     let total: Int = result.bits();\n                             ^~~~~~\n  565 |     let padding: Int = total % 8;\n\nUnsupported contract method access: id",
      "node_modules/@tact-lang/compiler/dist/stdlib/stdlib/std/internal/text.tact:   566 |     if (padding != 0) {\n> 567 |         let s: Slice = result.asSlice();\n                               ^~~~~~\n  568 |         return s.loadBits(total - padding);\n\nUnsupported contract method access: id",
      "node_modules/@tact-lang/compiler/dist/stdlib/stdlib/std/internal/contract.tact:   126 | inline extends fun hasSameBasechainAddress(self: StateInit, sender: Address): Bool {\n> 127 |     let senderAddress = parseStdAddress(sender.asSlice()).address;\n                                                ^~~~~~\n  128 |     let baseAddress = contractBasechainAddress(self);\n\nUnsupported contract method access: id",
      "node_modules/@tact-lang/compiler/dist/stdlib/stdlib/std/internal/send.tact:   495 |     //                     maybe: stateInit (false) bodyRef: bool (true)\n> 496 |     let c: Cell = beginCell()\n                          ^~~~~~~~~~~\n  497 |         .storeUint(15211807202738752817960438464513, 104)\n\nUnsupported contract method access: method_call",
      "node_modules/@tact-lang/compiler/dist/stdlib/stdlib/std/internal/send.tact:   495 |     //                     maybe: stateInit (false) bodyRef: bool (true)\n> 496 |     let c: Cell = beginCell()\n                          ^~~~~~~~~~~\n  497 |         .storeUint(15211807202738752817960438464513, 104)\n\nUnsupported contract method access: method_call",
      "node_modules/@tact-lang/compiler/dist/stdlib/stdlib/std/internal/send.tact:   495 |     //                     maybe: stateInit (false) bodyRef: bool (true)\n> 496 |     let c: Cell = beginCell()\n                          ^~~~~~~~~~~\n  497 |         .storeUint(15211807202738752817960438464513, 104)\n\nUnsupported contract method access: static_call",
      "node_modules/@tact-lang/compiler/dist/stdlib/stdlib/std/internal/address.tact:   23 |     // 256 bits for the address itself\n> 24 |     throwUnless(136, self.bits() == 267);\n                            ^~~~\n  25 | \n\nAccessing an unknown contract: self",
      "node_modules/@tact-lang/compiler/dist/stdlib/stdlib/std/internal/address.tact:   28 |         // i.e. internal address prefix and chain ID -1\n> 29 |         throwUnless(136, self.preloadUint(11) == 1279);\n                                ^~~~\n  30 |     } else {\n\nAccessing an unknown contract: self",
      "node_modules/@tact-lang/compiler/dist/stdlib/stdlib/std/internal/address.tact:   32 |         // but do not verify the chain ID\n> 33 |         throwUnless(136, self.preloadUint(3) == 4);\n                                ^~~~\n  34 |     }\n\nAccessing an unknown contract: self",
      "test/all/syntax.tact:   90 |     let m: map<Int, Int> = emptyMap();\n> 91 |     m.set(1, 10);\n           ^\n  92 |     m.set(2, 20);\n\nUnsupported contract method access: id",
      "test/all/syntax.tact:   91 |     m.set(1, 10);\n> 92 |     m.set(2, 20);\n           ^\n  93 |     m.set(3, 30);\n\nUnsupported contract method access: id",
      "test/all/syntax.tact:   92 |     m.set(2, 20);\n> 93 |     m.set(3, 30);\n           ^\n  94 | \n\nUnsupported contract method access: id",
      "test/all/syntax.tact:   173 | extends fun toInt(self: String): Int {\n> 174 |     let string: Slice = self.asSlice();\n                                ^~~~\n  175 |     let acc: Int = 0;\n\nAccessing an unknown contract: self",
      "test/all/syntax.tact:   176 |     while (!string.empty()) {\n> 177 |         let char: Int = string.loadUint(8);\n                                ^~~~~~\n  178 |         acc = (acc * 10) + (char - 48);\n\nUnsupported contract method access: id",
      "node_modules/@tact-lang/compiler/dist/stdlib/stdlib/std/internal/base.tact:   36 |     virtual inline fun reply(body: Cell?) {\n> 37 |         self.forward(sender(), body, true, null);\n               ^~~~\n  38 |     }\n\nAccessing an unknown contract: self",
      "node_modules/@tact-lang/compiler/dist/stdlib/stdlib/std/internal/base.tact:   52 |     virtual inline fun notify(body: Cell?) {\n> 53 |         self.forward(sender(), body, false, null);\n               ^~~~\n  54 |     }\n\nAccessing an unknown contract: self",
      "test/all/syntax.tact:   130 |         self.addr = newAddress(0, 0);\n> 131 |         self.b.storeAddress(self.addr);\n                ^~~~~~\n  132 |         self.s.b.storeAddress(self.addr);\n\nUnsupported contract method access: field_access",
      "test/all/syntax.tact:   131 |         self.b.storeAddress(self.addr);\n> 132 |         self.s.b.storeAddress(self.addr);\n                ^~~~~~~~\n  133 |     }\n\nUnsupported contract method access: field_access",
      "test/all/syntax.tact:   150 |         let a = beginString();\n> 151 |         a.append(\"f\");\n                ^\n  152 |     }\n\nUnsupported contract method access: id",
      "test/all/syntax.tact:   166 |         while (true) {\n> 167 |             self.m.set(1, 2);\n                    ^~~~~~\n  168 |         }\n\nUnsupported contract method access: field_access",
      "CGNode created without AST ID for function \"dump\"",
      "CGNode created without AST ID for function \"emptyMap\"",
      "CGNode created without AST ID for function \"m::set\"",
      "CGNode created without AST ID for function \"s::loadRefEx\"",
      "CGNode created without AST ID for function \"String::asSlice\"",
      "CGNode created without AST ID for function \"string::empty\"",
      "CGNode created without AST ID for function \"string::loadUint\"",
      "CGNode created without AST ID for function \"TestContractT::getA\"",
      "CGNode created without AST ID for function \"sender\"",
      "CGNode created without AST ID for function \"beginCell\"",
      "CGNode created without AST ID for function \"send\"",
      "CGNode created without AST ID for function \"s::loadAddress\"",
      "CGNode created without AST ID for function \"now\"",
      "CGNode created without AST ID for function \"nativeRandomizeLt\"",
      "CGNode created without AST ID for function \"beginString\"",
      "CGNode created without AST ID for function \"a::append\"",
      "Enabled detectors (36): DivideBeforeMultiply, ReadOnlyVariables, NeverAccessedVariables, UnboundLoop, ZeroAddress, ConstantAddress, BranchDuplicate, DumpIsUsed, FieldDoubleInit, PreferAugmentedAssign, StringReceiversOverlap, AsmIsUsed, PreferredStdlibApi, InheritedStateMutation, ArgCopyMutation, OptimalMathFunction, DuplicatedCondition, UnusedOptional, EnsurePrgSeed, FalseCondition, SendInLoop, UnboundMap, StateMutationInGetter, UnusedExpressionResult, SuspiciousMessageMode, ShortCircuitCondition, EtaLikeSimplifications, ExitCodeUsage, CellBounds, UnprotectedCall, SuspiciousLoop, SuboptimalSend, PreferBinaryReceiver, PreferSenderFunction, ImplicitOpcode, SuboptimalCellOperation",
      "Enabled tools (0): ",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Running detector for syntax",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector",
      "Finished detector"
    ],
    "info": [],
    "warn": [],
    "error": []
  }
}